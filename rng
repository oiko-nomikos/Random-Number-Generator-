#include <iostream>
#include <vector>
#include <deque>
#include <chrono>

class RandomNumberGenerator {
public:
    void run() {
        for (int i = 0; i < totalIterations; ++i) {
            long long duration = countdown();

            // Update global average using running mean
            ++count;
            globalSum += duration;
            globalAvg = globalSum / count;

            // Generate bit
            int bit = duration < globalAvg ? 0 : 1;

            // Push into local bits, maintaining a size of 512
            if (localBits.size() >= localBufferSize) {
                localBits.pop_front();  // remove oldest
            }
            localBits.push_back(bit);

            // Optional: Output progress
            std::cout << "Iteration " << i
                      << " | Duration: " << duration << " ns"
                      << " | Global Avg: " << globalAvg << " ns"
                      << " | Bit: " << bit << '\n';
        }

        // Final output of the 512-bit buffer
        std::cout << "\nLast 512 bits:\n";
        for (int bit : localBits) {
            std::cout << bit;
        }
        std::cout << std::endl;
    }

private:
    std::deque<int> localBits;  // store last 512 bits
    const int totalIterations = 10000;
    const size_t localBufferSize = 512;
    long long globalSum = 0;
    long long globalAvg = 0;
    int count = 0;

    long long countdown() {
        auto start = getTime();

        // Dummy workload
        int x = 10;
        while (x > 0) x--;

        auto end = getTime();
        return end - start;
    }

    long long getTime() {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
    }
};

int main() {
    RandomNumberGenerator rng;
    rng.run();
    return 0;
